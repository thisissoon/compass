// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/needle/v1/needle.proto

/*
Package needle is a generated protocol buffer package.

It is generated from these files:
	proto/needle/v1/needle.proto

It has these top-level messages:
	Service
	DelegationTable
	Dentry
	PutServiceRequest
	PutServiceResponse
	PutDentryRequest
	PutDentryResponse
	RouteToVersionRequest
	RouteToVersionResponse
	DeleteDentryByIdRequest
	DeleteDentryByIdResponse
	DeleteDentryByPrefixRequest
	DeleteDentryByPrefixResponse
	DelegationTablesRequest
	DelegationTablesResponse
*/
package needle

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A Service is a service that compass is managing a namerd dentry for
type Service struct {
	// Id - the primary key - but not used for upserts
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// User created date
	CreateDate *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=create_date,json=createDate" json:"create_date,omitempty"`
	// User updated date
	UpdateDate *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=update_date,json=updateDate" json:"update_date,omitempty"`
	// The logical name, e.g HTTP/1.1 Host name or HTTP/2 :authority
	LogicalName string `protobuf:"bytes,4,opt,name=logical_name,json=logicalName" json:"logical_name,omitempty"`
	// The kubernetets namespace the app runs in
	Namespace string `protobuf:"bytes,5,opt,name=namespace" json:"namespace,omitempty"`
	// Optional description of the service
	Description string `protobuf:"bytes,6,opt,name=description" json:"description,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Service) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Service) GetCreateDate() *google_protobuf.Timestamp {
	if m != nil {
		return m.CreateDate
	}
	return nil
}

func (m *Service) GetUpdateDate() *google_protobuf.Timestamp {
	if m != nil {
		return m.UpdateDate
	}
	return nil
}

func (m *Service) GetLogicalName() string {
	if m != nil {
		return m.LogicalName
	}
	return ""
}

func (m *Service) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Service) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// A DelegationTable holds any number of dentries
type DelegationTable struct {
	// Name of the delegation table
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DelegationTable) Reset()                    { *m = DelegationTable{} }
func (m *DelegationTable) String() string            { return proto.CompactTextString(m) }
func (*DelegationTable) ProtoMessage()               {}
func (*DelegationTable) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DelegationTable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// A Dentry is a single Delegation Table Rule
type Dentry struct {
	// Id - the primary key - but not used for upserts
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Optional description of the service
	ServiceId string `protobuf:"bytes,2,opt,name=service_id,json=serviceId" json:"service_id,omitempty"`
	// User created date
	CreateDate *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=create_date,json=createDate" json:"create_date,omitempty"`
	// User updated date
	UpdateDate *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=update_date,json=updateDate" json:"update_date,omitempty"`
	// The prefix to match on
	Prefix string `protobuf:"bytes,5,opt,name=prefix" json:"prefix,omitempty"`
	// The destination of the matched prefix
	Destination string `protobuf:"bytes,6,opt,name=destination" json:"destination,omitempty"`
	// The dentry dtab (k8s namespace)
	Dtab string `protobuf:"bytes,7,opt,name=dtab" json:"dtab,omitempty"`
	// Prioity of the dentry - affects the ordering within the delegation table
	Priority int32 `protobuf:"varint,8,opt,name=priority" json:"priority,omitempty"`
}

func (m *Dentry) Reset()                    { *m = Dentry{} }
func (m *Dentry) String() string            { return proto.CompactTextString(m) }
func (*Dentry) ProtoMessage()               {}
func (*Dentry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Dentry) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Dentry) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *Dentry) GetCreateDate() *google_protobuf.Timestamp {
	if m != nil {
		return m.CreateDate
	}
	return nil
}

func (m *Dentry) GetUpdateDate() *google_protobuf.Timestamp {
	if m != nil {
		return m.UpdateDate
	}
	return nil
}

func (m *Dentry) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Dentry) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Dentry) GetDtab() string {
	if m != nil {
		return m.Dtab
	}
	return ""
}

func (m *Dentry) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// Request for [PutService](compass.needle.v1.NeedleService.PutService)
type PutServiceRequest struct {
	// Service to be created or updated
	Service *Service `protobuf:"bytes,1,opt,name=service" json:"service,omitempty"`
}

func (m *PutServiceRequest) Reset()                    { *m = PutServiceRequest{} }
func (m *PutServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*PutServiceRequest) ProtoMessage()               {}
func (*PutServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *PutServiceRequest) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

// Response for [PutService](compass.needle.v1.NeedleService.PutService)
type PutServiceResponse struct {
	// Service crated or updated
	Service *Service `protobuf:"bytes,1,opt,name=service" json:"service,omitempty"`
}

func (m *PutServiceResponse) Reset()                    { *m = PutServiceResponse{} }
func (m *PutServiceResponse) String() string            { return proto.CompactTextString(m) }
func (*PutServiceResponse) ProtoMessage()               {}
func (*PutServiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PutServiceResponse) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

// Request for [PutDentry](compass.needle.v1.NeedleService.PutDentry)
type PutDentryRequest struct {
	// Dentry to create or update
	Dentry *Dentry `protobuf:"bytes,1,opt,name=dentry" json:"dentry,omitempty"`
}

func (m *PutDentryRequest) Reset()                    { *m = PutDentryRequest{} }
func (m *PutDentryRequest) String() string            { return proto.CompactTextString(m) }
func (*PutDentryRequest) ProtoMessage()               {}
func (*PutDentryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *PutDentryRequest) GetDentry() *Dentry {
	if m != nil {
		return m.Dentry
	}
	return nil
}

// Response for [PutDentry](compass.needle.v1.NeedleService.PutDentry)
type PutDentryResponse struct {
	// Dentry crated or updated
	Dentry *Dentry `protobuf:"bytes,1,opt,name=dentry" json:"dentry,omitempty"`
}

func (m *PutDentryResponse) Reset()                    { *m = PutDentryResponse{} }
func (m *PutDentryResponse) String() string            { return proto.CompactTextString(m) }
func (*PutDentryResponse) ProtoMessage()               {}
func (*PutDentryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PutDentryResponse) GetDentry() *Dentry {
	if m != nil {
		return m.Dentry
	}
	return nil
}

// Request for [RouteToVersion](compass.needle.v1.NeedleService.RouteToVersion)
type RouteToVersionRequest struct {
	// Logical name of the service to route
	LogicalName string `protobuf:"bytes,1,opt,name=logical_name,json=logicalName" json:"logical_name,omitempty"`
	// Version string of the kubernetets service to route too
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *RouteToVersionRequest) Reset()                    { *m = RouteToVersionRequest{} }
func (m *RouteToVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*RouteToVersionRequest) ProtoMessage()               {}
func (*RouteToVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *RouteToVersionRequest) GetLogicalName() string {
	if m != nil {
		return m.LogicalName
	}
	return ""
}

func (m *RouteToVersionRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// Response for [RouteToVersion](compass.needle.v1.NeedleService.RouteToVersion)
type RouteToVersionResponse struct {
}

func (m *RouteToVersionResponse) Reset()                    { *m = RouteToVersionResponse{} }
func (m *RouteToVersionResponse) String() string            { return proto.CompactTextString(m) }
func (*RouteToVersionResponse) ProtoMessage()               {}
func (*RouteToVersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// Request for [DeleteDentryById](compass.needle.v1.NeedleService.DeleteDentryById)
type DeleteDentryByIdRequest struct {
	// Id of the dentry to delete
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *DeleteDentryByIdRequest) Reset()                    { *m = DeleteDentryByIdRequest{} }
func (m *DeleteDentryByIdRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteDentryByIdRequest) ProtoMessage()               {}
func (*DeleteDentryByIdRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *DeleteDentryByIdRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Response for [DeleteDentryById](compass.needle.v1.NeedleService.DeleteDentryById)
type DeleteDentryByIdResponse struct {
	// Indicates if the dentry was deleted
	Deleted bool `protobuf:"varint,1,opt,name=deleted" json:"deleted,omitempty"`
}

func (m *DeleteDentryByIdResponse) Reset()                    { *m = DeleteDentryByIdResponse{} }
func (m *DeleteDentryByIdResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteDentryByIdResponse) ProtoMessage()               {}
func (*DeleteDentryByIdResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DeleteDentryByIdResponse) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

// Request for [DeleteDentryByPrefix](compass.needle.v1.NeedleService.DeleteDentryByPrefix)
type DeleteDentryByPrefixRequest struct {
	// Deletegation table the dentry is in
	Dtab string `protobuf:"bytes,1,opt,name=dtab" json:"dtab,omitempty"`
	// The dentry predfix
	Prefix string `protobuf:"bytes,2,opt,name=prefix" json:"prefix,omitempty"`
}

func (m *DeleteDentryByPrefixRequest) Reset()                    { *m = DeleteDentryByPrefixRequest{} }
func (m *DeleteDentryByPrefixRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteDentryByPrefixRequest) ProtoMessage()               {}
func (*DeleteDentryByPrefixRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DeleteDentryByPrefixRequest) GetDtab() string {
	if m != nil {
		return m.Dtab
	}
	return ""
}

func (m *DeleteDentryByPrefixRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// Response for [DeleteDentryByPrefix](compass.needle.v1.NeedleService.DeleteDentryByPrefix)
type DeleteDentryByPrefixResponse struct {
	// Indicates if the dentry was deleted
	Deleted bool `protobuf:"varint,1,opt,name=deleted" json:"deleted,omitempty"`
}

func (m *DeleteDentryByPrefixResponse) Reset()                    { *m = DeleteDentryByPrefixResponse{} }
func (m *DeleteDentryByPrefixResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteDentryByPrefixResponse) ProtoMessage()               {}
func (*DeleteDentryByPrefixResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DeleteDentryByPrefixResponse) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

// Request for [DelegationTables](compass.needle.v1.NeedleService.DelegationTables)
type DelegationTablesRequest struct {
}

func (m *DelegationTablesRequest) Reset()                    { *m = DelegationTablesRequest{} }
func (m *DelegationTablesRequest) String() string            { return proto.CompactTextString(m) }
func (*DelegationTablesRequest) ProtoMessage()               {}
func (*DelegationTablesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

// Response for [DelegationTables](compass.needle.v1.NeedleService.DelegationTables)
type DelegationTablesResponse struct {
	// Delegation tables
	DelegationTables []*DelegationTable `protobuf:"bytes,1,rep,name=delegation_tables,json=delegationTables" json:"delegation_tables,omitempty"`
}

func (m *DelegationTablesResponse) Reset()                    { *m = DelegationTablesResponse{} }
func (m *DelegationTablesResponse) String() string            { return proto.CompactTextString(m) }
func (*DelegationTablesResponse) ProtoMessage()               {}
func (*DelegationTablesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *DelegationTablesResponse) GetDelegationTables() []*DelegationTable {
	if m != nil {
		return m.DelegationTables
	}
	return nil
}

func init() {
	proto.RegisterType((*Service)(nil), "compass.needle.v1.Service")
	proto.RegisterType((*DelegationTable)(nil), "compass.needle.v1.DelegationTable")
	proto.RegisterType((*Dentry)(nil), "compass.needle.v1.Dentry")
	proto.RegisterType((*PutServiceRequest)(nil), "compass.needle.v1.PutServiceRequest")
	proto.RegisterType((*PutServiceResponse)(nil), "compass.needle.v1.PutServiceResponse")
	proto.RegisterType((*PutDentryRequest)(nil), "compass.needle.v1.PutDentryRequest")
	proto.RegisterType((*PutDentryResponse)(nil), "compass.needle.v1.PutDentryResponse")
	proto.RegisterType((*RouteToVersionRequest)(nil), "compass.needle.v1.RouteToVersionRequest")
	proto.RegisterType((*RouteToVersionResponse)(nil), "compass.needle.v1.RouteToVersionResponse")
	proto.RegisterType((*DeleteDentryByIdRequest)(nil), "compass.needle.v1.DeleteDentryByIdRequest")
	proto.RegisterType((*DeleteDentryByIdResponse)(nil), "compass.needle.v1.DeleteDentryByIdResponse")
	proto.RegisterType((*DeleteDentryByPrefixRequest)(nil), "compass.needle.v1.DeleteDentryByPrefixRequest")
	proto.RegisterType((*DeleteDentryByPrefixResponse)(nil), "compass.needle.v1.DeleteDentryByPrefixResponse")
	proto.RegisterType((*DelegationTablesRequest)(nil), "compass.needle.v1.DelegationTablesRequest")
	proto.RegisterType((*DelegationTablesResponse)(nil), "compass.needle.v1.DelegationTablesResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NeedleService service

type NeedleServiceClient interface {
	// PutService upserts services to be managed
	PutService(ctx context.Context, in *PutServiceRequest, opts ...grpc.CallOption) (*PutServiceResponse, error)
	// PutDentry upserts dentries to be managed
	PutDentry(ctx context.Context, in *PutDentryRequest, opts ...grpc.CallOption) (*PutDentryResponse, error)
	// DelegationTables returns a list of delegation tables we are managing
	DelegationTables(ctx context.Context, in *DelegationTablesRequest, opts ...grpc.CallOption) (*DelegationTablesResponse, error)
	// DeleteDentryById deletes a dentry by it's UUID
	DeleteDentryById(ctx context.Context, in *DeleteDentryByIdRequest, opts ...grpc.CallOption) (*DeleteDentryByIdResponse, error)
	// DeleteDentryByPrefix deletes a dentry by prefix within a dtab
	DeleteDentryByPrefix(ctx context.Context, in *DeleteDentryByPrefixRequest, opts ...grpc.CallOption) (*DeleteDentryByPrefixResponse, error)
	// RouteToVersion routes a specific logical name to a specifc lubernetets services
	// based on a services logicalName and version labels
	RouteToVersion(ctx context.Context, in *RouteToVersionRequest, opts ...grpc.CallOption) (*RouteToVersionResponse, error)
}

type needleServiceClient struct {
	cc *grpc.ClientConn
}

func NewNeedleServiceClient(cc *grpc.ClientConn) NeedleServiceClient {
	return &needleServiceClient{cc}
}

func (c *needleServiceClient) PutService(ctx context.Context, in *PutServiceRequest, opts ...grpc.CallOption) (*PutServiceResponse, error) {
	out := new(PutServiceResponse)
	err := grpc.Invoke(ctx, "/compass.needle.v1.NeedleService/PutService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *needleServiceClient) PutDentry(ctx context.Context, in *PutDentryRequest, opts ...grpc.CallOption) (*PutDentryResponse, error) {
	out := new(PutDentryResponse)
	err := grpc.Invoke(ctx, "/compass.needle.v1.NeedleService/PutDentry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *needleServiceClient) DelegationTables(ctx context.Context, in *DelegationTablesRequest, opts ...grpc.CallOption) (*DelegationTablesResponse, error) {
	out := new(DelegationTablesResponse)
	err := grpc.Invoke(ctx, "/compass.needle.v1.NeedleService/DelegationTables", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *needleServiceClient) DeleteDentryById(ctx context.Context, in *DeleteDentryByIdRequest, opts ...grpc.CallOption) (*DeleteDentryByIdResponse, error) {
	out := new(DeleteDentryByIdResponse)
	err := grpc.Invoke(ctx, "/compass.needle.v1.NeedleService/DeleteDentryById", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *needleServiceClient) DeleteDentryByPrefix(ctx context.Context, in *DeleteDentryByPrefixRequest, opts ...grpc.CallOption) (*DeleteDentryByPrefixResponse, error) {
	out := new(DeleteDentryByPrefixResponse)
	err := grpc.Invoke(ctx, "/compass.needle.v1.NeedleService/DeleteDentryByPrefix", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *needleServiceClient) RouteToVersion(ctx context.Context, in *RouteToVersionRequest, opts ...grpc.CallOption) (*RouteToVersionResponse, error) {
	out := new(RouteToVersionResponse)
	err := grpc.Invoke(ctx, "/compass.needle.v1.NeedleService/RouteToVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NeedleService service

type NeedleServiceServer interface {
	// PutService upserts services to be managed
	PutService(context.Context, *PutServiceRequest) (*PutServiceResponse, error)
	// PutDentry upserts dentries to be managed
	PutDentry(context.Context, *PutDentryRequest) (*PutDentryResponse, error)
	// DelegationTables returns a list of delegation tables we are managing
	DelegationTables(context.Context, *DelegationTablesRequest) (*DelegationTablesResponse, error)
	// DeleteDentryById deletes a dentry by it's UUID
	DeleteDentryById(context.Context, *DeleteDentryByIdRequest) (*DeleteDentryByIdResponse, error)
	// DeleteDentryByPrefix deletes a dentry by prefix within a dtab
	DeleteDentryByPrefix(context.Context, *DeleteDentryByPrefixRequest) (*DeleteDentryByPrefixResponse, error)
	// RouteToVersion routes a specific logical name to a specifc lubernetets services
	// based on a services logicalName and version labels
	RouteToVersion(context.Context, *RouteToVersionRequest) (*RouteToVersionResponse, error)
}

func RegisterNeedleServiceServer(s *grpc.Server, srv NeedleServiceServer) {
	s.RegisterService(&_NeedleService_serviceDesc, srv)
}

func _NeedleService_PutService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NeedleServiceServer).PutService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.needle.v1.NeedleService/PutService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NeedleServiceServer).PutService(ctx, req.(*PutServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NeedleService_PutDentry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutDentryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NeedleServiceServer).PutDentry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.needle.v1.NeedleService/PutDentry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NeedleServiceServer).PutDentry(ctx, req.(*PutDentryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NeedleService_DelegationTables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelegationTablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NeedleServiceServer).DelegationTables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.needle.v1.NeedleService/DelegationTables",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NeedleServiceServer).DelegationTables(ctx, req.(*DelegationTablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NeedleService_DeleteDentryById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDentryByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NeedleServiceServer).DeleteDentryById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.needle.v1.NeedleService/DeleteDentryById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NeedleServiceServer).DeleteDentryById(ctx, req.(*DeleteDentryByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NeedleService_DeleteDentryByPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDentryByPrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NeedleServiceServer).DeleteDentryByPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.needle.v1.NeedleService/DeleteDentryByPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NeedleServiceServer).DeleteDentryByPrefix(ctx, req.(*DeleteDentryByPrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NeedleService_RouteToVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteToVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NeedleServiceServer).RouteToVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.needle.v1.NeedleService/RouteToVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NeedleServiceServer).RouteToVersion(ctx, req.(*RouteToVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NeedleService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "compass.needle.v1.NeedleService",
	HandlerType: (*NeedleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PutService",
			Handler:    _NeedleService_PutService_Handler,
		},
		{
			MethodName: "PutDentry",
			Handler:    _NeedleService_PutDentry_Handler,
		},
		{
			MethodName: "DelegationTables",
			Handler:    _NeedleService_DelegationTables_Handler,
		},
		{
			MethodName: "DeleteDentryById",
			Handler:    _NeedleService_DeleteDentryById_Handler,
		},
		{
			MethodName: "DeleteDentryByPrefix",
			Handler:    _NeedleService_DeleteDentryByPrefix_Handler,
		},
		{
			MethodName: "RouteToVersion",
			Handler:    _NeedleService_RouteToVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/needle/v1/needle.proto",
}

func init() { proto.RegisterFile("proto/needle/v1/needle.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 686 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xad, 0xd3, 0x36, 0x69, 0x26, 0x50, 0xd2, 0x15, 0x14, 0xd7, 0x14, 0x11, 0x96, 0x56, 0x4a,
	0x41, 0x72, 0xd4, 0xd2, 0x03, 0x52, 0x6f, 0x55, 0x41, 0x0a, 0x87, 0x52, 0x99, 0x08, 0x21, 0x38,
	0x44, 0x4e, 0x76, 0x1a, 0xad, 0x48, 0x6c, 0x63, 0x6f, 0x22, 0xf2, 0x0f, 0xf8, 0x0f, 0xfc, 0x4f,
	0xce, 0xc8, 0xfb, 0xe1, 0x26, 0x8e, 0x4b, 0x42, 0xb9, 0xed, 0xce, 0xbe, 0xf7, 0x66, 0xf6, 0xf9,
	0xd9, 0x09, 0xec, 0x47, 0x71, 0x28, 0xc2, 0x56, 0x80, 0xc8, 0x86, 0xd8, 0x9a, 0x1c, 0xeb, 0x95,
	0x2b, 0xcb, 0x64, 0xa7, 0x1f, 0x8e, 0x22, 0x3f, 0x49, 0x5c, 0x5d, 0x9d, 0x1c, 0x3b, 0xcf, 0x06,
	0x61, 0x38, 0x18, 0x62, 0x4b, 0x02, 0x7a, 0xe3, 0xeb, 0x96, 0xe0, 0x23, 0x4c, 0x84, 0x3f, 0x8a,
	0x14, 0x87, 0xfe, 0xb6, 0xa0, 0xf2, 0x11, 0xe3, 0x09, 0xef, 0x23, 0xd9, 0x86, 0x12, 0x67, 0xb6,
	0xd5, 0xb0, 0x9a, 0x55, 0xaf, 0xc4, 0x19, 0x39, 0x83, 0x5a, 0x3f, 0x46, 0x5f, 0x60, 0x97, 0xf9,
	0x02, 0xed, 0x52, 0xc3, 0x6a, 0xd6, 0x4e, 0x1c, 0x57, 0x49, 0xba, 0x46, 0xd2, 0xed, 0x18, 0x49,
	0x0f, 0x14, 0xfc, 0xc2, 0x17, 0x98, 0x92, 0xc7, 0x11, 0xcb, 0xc8, 0xeb, 0xcb, 0xc9, 0x0a, 0x2e,
	0xc9, 0xcf, 0xe1, 0xde, 0x30, 0x1c, 0xf0, 0xbe, 0x3f, 0xec, 0x06, 0xfe, 0x08, 0xed, 0x0d, 0x39,
	0x53, 0x4d, 0xd7, 0x2e, 0xfd, 0x11, 0x92, 0x7d, 0xa8, 0xa6, 0x47, 0x49, 0xe4, 0xf7, 0xd1, 0xde,
	0x94, 0xe7, 0x37, 0x05, 0xd2, 0x80, 0x1a, 0xc3, 0xa4, 0x1f, 0xf3, 0x48, 0xf0, 0x30, 0xb0, 0xcb,
	0x8a, 0x3f, 0x53, 0xa2, 0x87, 0xf0, 0xe0, 0x02, 0x87, 0x38, 0xf0, 0xd3, 0x5d, 0xc7, 0xef, 0x0d,
	0x91, 0x10, 0xd8, 0x90, 0xdd, 0x94, 0x03, 0x72, 0x4d, 0x7f, 0x95, 0xa0, 0x7c, 0x81, 0x81, 0x88,
	0xa7, 0x0b, 0xf6, 0x3c, 0x05, 0x48, 0x94, 0x73, 0x5d, 0xce, 0xa4, 0x3b, 0x55, 0xaf, 0xaa, 0x2b,
	0xed, 0x05, 0xf7, 0xd6, 0xff, 0xc7, 0xbd, 0x8d, 0x7f, 0x72, 0x6f, 0x17, 0xca, 0x51, 0x8c, 0xd7,
	0xfc, 0x87, 0xf6, 0x45, 0xef, 0xb4, 0x29, 0x82, 0x07, 0x7e, 0xce, 0x14, 0x53, 0x4a, 0x1d, 0x60,
	0xc2, 0xef, 0xd9, 0x15, 0xe5, 0x40, 0xba, 0x26, 0x0e, 0x6c, 0x45, 0x31, 0x0f, 0x63, 0x2e, 0xa6,
	0xf6, 0x56, 0xc3, 0x6a, 0x6e, 0x7a, 0xd9, 0x9e, 0xb6, 0x61, 0xe7, 0x6a, 0x2c, 0x74, 0x7e, 0x3c,
	0xfc, 0x3e, 0xc6, 0x44, 0x90, 0x53, 0xa8, 0x68, 0x17, 0xa4, 0x59, 0xe9, 0xdc, 0x0b, 0xc1, 0x74,
	0x0d, 0xc7, 0x40, 0xe9, 0x7b, 0x20, 0xb3, 0x52, 0x49, 0x14, 0x06, 0x09, 0xde, 0x51, 0xeb, 0x2d,
	0xd4, 0xaf, 0xc6, 0x42, 0x3d, 0x36, 0x33, 0xd5, 0x31, 0x94, 0x99, 0x2c, 0x68, 0xa1, 0xbd, 0x02,
	0x21, 0xcd, 0xd0, 0x40, 0xfa, 0x4e, 0xde, 0xce, 0xc8, 0xe8, 0x89, 0xee, 0xa0, 0xd3, 0x81, 0x47,
	0x5e, 0x38, 0x16, 0xd8, 0x09, 0x3f, 0x61, 0x9c, 0xf0, 0x30, 0x30, 0x33, 0xe5, 0x63, 0x6e, 0x2d,
	0xc6, 0xdc, 0x86, 0xca, 0x44, 0x91, 0x64, 0x82, 0xaa, 0x9e, 0xd9, 0x52, 0x1b, 0x76, 0xf3, 0xaa,
	0x6a, 0x44, 0x7a, 0x04, 0x8f, 0xd3, 0x68, 0x0b, 0x54, 0x73, 0x9c, 0x4f, 0xdb, 0xcc, 0x74, 0xcc,
	0x65, 0x98, 0x9e, 0x82, 0xbd, 0x08, 0xd5, 0x37, 0xb5, 0xa1, 0xc2, 0xe4, 0x99, 0x22, 0x6c, 0x79,
	0x66, 0x4b, 0xdb, 0xf0, 0x64, 0x9e, 0x75, 0x25, 0x03, 0x66, 0x9a, 0x98, 0x14, 0x59, 0x33, 0x29,
	0xba, 0xc9, 0x64, 0x69, 0x36, 0x93, 0xf4, 0x0d, 0xec, 0x17, 0x4b, 0x2d, 0x1d, 0x62, 0x4f, 0xdd,
	0x72, 0xe6, 0x05, 0x4e, 0xf4, 0x00, 0xf4, 0x9b, 0xba, 0xd5, 0xfc, 0x91, 0x16, 0xfc, 0x00, 0x3b,
	0x2c, 0x3b, 0xeb, 0x0a, 0x79, 0x68, 0x5b, 0x8d, 0xf5, 0x66, 0xed, 0x84, 0x16, 0x3e, 0xca, 0x39,
	0x1d, 0xaf, 0xce, 0x72, 0xc2, 0x27, 0x3f, 0x37, 0xe1, 0xfe, 0xa5, 0xc4, 0x9b, 0xef, 0xe8, 0x57,
	0x80, 0x9b, 0x28, 0x93, 0x83, 0x02, 0xd5, 0x85, 0x97, 0xc6, 0x39, 0x5c, 0x82, 0xd2, 0x8f, 0x76,
	0x8d, 0x7c, 0x86, 0x6a, 0x16, 0x4a, 0xf2, 0xa2, 0x98, 0x35, 0x97, 0x7c, 0xe7, 0xe0, 0xef, 0xa0,
	0x4c, 0x79, 0x04, 0xf5, 0xbc, 0x6b, 0xe4, 0xe5, 0x72, 0x4b, 0x8c, 0xeb, 0xce, 0xab, 0x95, 0xb0,
	0xf9, 0x76, 0xb3, 0xd1, 0xbb, 0xb5, 0x5d, 0x41, 0x94, 0x6f, 0x6d, 0x57, 0x94, 0x65, 0xba, 0x46,
	0xa6, 0xf0, 0xb0, 0x28, 0x68, 0xc4, 0x5d, 0x2a, 0x33, 0x17, 0x6e, 0xa7, 0xb5, 0x32, 0x3e, 0x6b,
	0x3d, 0x80, 0xed, 0xf9, 0x37, 0x95, 0x34, 0x0b, 0x44, 0x0a, 0x3f, 0x11, 0xce, 0xd1, 0x0a, 0x48,
	0xd3, 0xe8, 0x9c, 0x7c, 0xa9, 0x67, 0x7f, 0x0d, 0xce, 0xd4, 0xaa, 0x57, 0x96, 0x3f, 0x16, 0xaf,
	0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x66, 0x2c, 0xf8, 0x63, 0x3b, 0x08, 0x00, 0x00,
}
