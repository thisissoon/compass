// Code generated by protoc-gen-go. DO NOT EDIT.
// source: services/needle.proto

/*
Package services is a generated protocol buffer package.

It is generated from these files:
	services/needle.proto

It has these top-level messages:
	DataMigrationUpgradeRequest
	DataMigrationUpgradeResponse
	DataMigrationVersionRequest
	DataMigrationVersionResponse
	Service
	DelegationTable
	Dentry
	PutServiceRequest
	PutServiceResponse
	PutDentryRequest
	PutDentryResponse
	RouteToVersionRequest
	RouteToVersionResponse
	DeleteDentryByIdRequest
	DeleteDentryByIdResponse
	DeleteDentryByPrefixRequest
	DeleteDentryByPrefixResponse
	DelegationTablesRequest
	DelegationTablesResponse
	DentriesRequest
	DentriesResponse
*/
package services

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Request for [Upgrade](services.migration.DataMigrationService.Upgrade)
type DataMigrationUpgradeRequest struct {
}

func (m *DataMigrationUpgradeRequest) Reset()                    { *m = DataMigrationUpgradeRequest{} }
func (m *DataMigrationUpgradeRequest) String() string            { return proto.CompactTextString(m) }
func (*DataMigrationUpgradeRequest) ProtoMessage()               {}
func (*DataMigrationUpgradeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Response for [Upgrade](services.migration.DataMigrationService.Upgrade)
type DataMigrationUpgradeResponse struct {
}

func (m *DataMigrationUpgradeResponse) Reset()                    { *m = DataMigrationUpgradeResponse{} }
func (m *DataMigrationUpgradeResponse) String() string            { return proto.CompactTextString(m) }
func (*DataMigrationUpgradeResponse) ProtoMessage()               {}
func (*DataMigrationUpgradeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Request for [Version](services.migration.DataMigrationService.Version)
type DataMigrationVersionRequest struct {
}

func (m *DataMigrationVersionRequest) Reset()                    { *m = DataMigrationVersionRequest{} }
func (m *DataMigrationVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*DataMigrationVersionRequest) ProtoMessage()               {}
func (*DataMigrationVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Response for [Version](services.migration.DataMigrationService.Version)
type DataMigrationVersionResponse struct {
	// Schema version
	Version uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
}

func (m *DataMigrationVersionResponse) Reset()                    { *m = DataMigrationVersionResponse{} }
func (m *DataMigrationVersionResponse) String() string            { return proto.CompactTextString(m) }
func (*DataMigrationVersionResponse) ProtoMessage()               {}
func (*DataMigrationVersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DataMigrationVersionResponse) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

// A Service is a service that compass is managing a namerd dentry for
type Service struct {
	// Id - the primary key - but not used for upserts
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// User created date
	CreateDate *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=create_date,json=createDate" json:"create_date,omitempty"`
	// User updated date
	UpdateDate *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=update_date,json=updateDate" json:"update_date,omitempty"`
	// The logical name, e.g HTTP/1.1 Host name or HTTP/2 :authority
	LogicalName string `protobuf:"bytes,4,opt,name=logical_name,json=logicalName" json:"logical_name,omitempty"`
	// The kubernetets namespace the app runs in
	Namespace string `protobuf:"bytes,5,opt,name=namespace" json:"namespace,omitempty"`
	// Optional description of the service
	Description string `protobuf:"bytes,6,opt,name=description" json:"description,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Service) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Service) GetCreateDate() *google_protobuf.Timestamp {
	if m != nil {
		return m.CreateDate
	}
	return nil
}

func (m *Service) GetUpdateDate() *google_protobuf.Timestamp {
	if m != nil {
		return m.UpdateDate
	}
	return nil
}

func (m *Service) GetLogicalName() string {
	if m != nil {
		return m.LogicalName
	}
	return ""
}

func (m *Service) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Service) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// A DelegationTable holds any number of dentries
type DelegationTable struct {
	// Name of the delegation table
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DelegationTable) Reset()                    { *m = DelegationTable{} }
func (m *DelegationTable) String() string            { return proto.CompactTextString(m) }
func (*DelegationTable) ProtoMessage()               {}
func (*DelegationTable) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DelegationTable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// A Dentry is a single Delegation Table Rule
type Dentry struct {
	// Id - the primary key - but not used for upserts
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Optional description of the service
	ServiceId string `protobuf:"bytes,2,opt,name=service_id,json=serviceId" json:"service_id,omitempty"`
	// User created date
	CreateDate *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=create_date,json=createDate" json:"create_date,omitempty"`
	// User updated date
	UpdateDate *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=update_date,json=updateDate" json:"update_date,omitempty"`
	// The prefix to match on
	Prefix string `protobuf:"bytes,5,opt,name=prefix" json:"prefix,omitempty"`
	// The destination of the matched prefix
	Destination string `protobuf:"bytes,6,opt,name=destination" json:"destination,omitempty"`
	// The dentry dtab (k8s namespace)
	Dtab string `protobuf:"bytes,7,opt,name=dtab" json:"dtab,omitempty"`
	// Prioity of the dentry - affects the ordering within the delegation table
	Priority int32 `protobuf:"varint,8,opt,name=priority" json:"priority,omitempty"`
}

func (m *Dentry) Reset()                    { *m = Dentry{} }
func (m *Dentry) String() string            { return proto.CompactTextString(m) }
func (*Dentry) ProtoMessage()               {}
func (*Dentry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Dentry) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Dentry) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *Dentry) GetCreateDate() *google_protobuf.Timestamp {
	if m != nil {
		return m.CreateDate
	}
	return nil
}

func (m *Dentry) GetUpdateDate() *google_protobuf.Timestamp {
	if m != nil {
		return m.UpdateDate
	}
	return nil
}

func (m *Dentry) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Dentry) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Dentry) GetDtab() string {
	if m != nil {
		return m.Dtab
	}
	return ""
}

func (m *Dentry) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// Request for [PutService](compass.needle.v1.NeedleService.PutService)
type PutServiceRequest struct {
	// Service to be created or updated
	Service *Service `protobuf:"bytes,1,opt,name=service" json:"service,omitempty"`
}

func (m *PutServiceRequest) Reset()                    { *m = PutServiceRequest{} }
func (m *PutServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*PutServiceRequest) ProtoMessage()               {}
func (*PutServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PutServiceRequest) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

// Response for [PutService](compass.needle.v1.NeedleService.PutService)
type PutServiceResponse struct {
	// Service crated or updated
	Service *Service `protobuf:"bytes,1,opt,name=service" json:"service,omitempty"`
}

func (m *PutServiceResponse) Reset()                    { *m = PutServiceResponse{} }
func (m *PutServiceResponse) String() string            { return proto.CompactTextString(m) }
func (*PutServiceResponse) ProtoMessage()               {}
func (*PutServiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *PutServiceResponse) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

// Request for [PutDentry](compass.needle.v1.NeedleService.PutDentry)
type PutDentryRequest struct {
	// Dentry to create or update
	Dentry *Dentry `protobuf:"bytes,1,opt,name=dentry" json:"dentry,omitempty"`
}

func (m *PutDentryRequest) Reset()                    { *m = PutDentryRequest{} }
func (m *PutDentryRequest) String() string            { return proto.CompactTextString(m) }
func (*PutDentryRequest) ProtoMessage()               {}
func (*PutDentryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *PutDentryRequest) GetDentry() *Dentry {
	if m != nil {
		return m.Dentry
	}
	return nil
}

// Response for [PutDentry](compass.needle.v1.NeedleService.PutDentry)
type PutDentryResponse struct {
	// Dentry crated or updated
	Dentry *Dentry `protobuf:"bytes,1,opt,name=dentry" json:"dentry,omitempty"`
}

func (m *PutDentryResponse) Reset()                    { *m = PutDentryResponse{} }
func (m *PutDentryResponse) String() string            { return proto.CompactTextString(m) }
func (*PutDentryResponse) ProtoMessage()               {}
func (*PutDentryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *PutDentryResponse) GetDentry() *Dentry {
	if m != nil {
		return m.Dentry
	}
	return nil
}

// Request for [RouteToVersion](compass.needle.v1.NeedleService.RouteToVersion)
type RouteToVersionRequest struct {
	// Logical name of the service to route
	LogicalName string `protobuf:"bytes,1,opt,name=logical_name,json=logicalName" json:"logical_name,omitempty"`
	// Version string of the kubernetets service to route too
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *RouteToVersionRequest) Reset()                    { *m = RouteToVersionRequest{} }
func (m *RouteToVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*RouteToVersionRequest) ProtoMessage()               {}
func (*RouteToVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *RouteToVersionRequest) GetLogicalName() string {
	if m != nil {
		return m.LogicalName
	}
	return ""
}

func (m *RouteToVersionRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// Response for [RouteToVersion](compass.needle.v1.NeedleService.RouteToVersion)
type RouteToVersionResponse struct {
}

func (m *RouteToVersionResponse) Reset()                    { *m = RouteToVersionResponse{} }
func (m *RouteToVersionResponse) String() string            { return proto.CompactTextString(m) }
func (*RouteToVersionResponse) ProtoMessage()               {}
func (*RouteToVersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

// Request for [DeleteDentryById](compass.needle.v1.NeedleService.DeleteDentryById)
type DeleteDentryByIdRequest struct {
	// Id of the dentry to delete
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *DeleteDentryByIdRequest) Reset()                    { *m = DeleteDentryByIdRequest{} }
func (m *DeleteDentryByIdRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteDentryByIdRequest) ProtoMessage()               {}
func (*DeleteDentryByIdRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *DeleteDentryByIdRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Response for [DeleteDentryById](compass.needle.v1.NeedleService.DeleteDentryById)
type DeleteDentryByIdResponse struct {
	// Indicates if the dentry was deleted
	Deleted bool `protobuf:"varint,1,opt,name=deleted" json:"deleted,omitempty"`
}

func (m *DeleteDentryByIdResponse) Reset()                    { *m = DeleteDentryByIdResponse{} }
func (m *DeleteDentryByIdResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteDentryByIdResponse) ProtoMessage()               {}
func (*DeleteDentryByIdResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *DeleteDentryByIdResponse) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

// Request for [DeleteDentryByPrefix](compass.needle.v1.NeedleService.DeleteDentryByPrefix)
type DeleteDentryByPrefixRequest struct {
	// Deletegation table the dentry is in
	Dtab string `protobuf:"bytes,1,opt,name=dtab" json:"dtab,omitempty"`
	// The dentry predfix
	Prefix string `protobuf:"bytes,2,opt,name=prefix" json:"prefix,omitempty"`
}

func (m *DeleteDentryByPrefixRequest) Reset()                    { *m = DeleteDentryByPrefixRequest{} }
func (m *DeleteDentryByPrefixRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteDentryByPrefixRequest) ProtoMessage()               {}
func (*DeleteDentryByPrefixRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *DeleteDentryByPrefixRequest) GetDtab() string {
	if m != nil {
		return m.Dtab
	}
	return ""
}

func (m *DeleteDentryByPrefixRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// Response for [DeleteDentryByPrefix](compass.needle.v1.NeedleService.DeleteDentryByPrefix)
type DeleteDentryByPrefixResponse struct {
	// Indicates if the dentry was deleted
	Deleted bool `protobuf:"varint,1,opt,name=deleted" json:"deleted,omitempty"`
}

func (m *DeleteDentryByPrefixResponse) Reset()                    { *m = DeleteDentryByPrefixResponse{} }
func (m *DeleteDentryByPrefixResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteDentryByPrefixResponse) ProtoMessage()               {}
func (*DeleteDentryByPrefixResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *DeleteDentryByPrefixResponse) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

// Request for [DelegationTables](compass.needle.v1.NeedleService.DelegationTables)
type DelegationTablesRequest struct {
}

func (m *DelegationTablesRequest) Reset()                    { *m = DelegationTablesRequest{} }
func (m *DelegationTablesRequest) String() string            { return proto.CompactTextString(m) }
func (*DelegationTablesRequest) ProtoMessage()               {}
func (*DelegationTablesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

// Response for [DelegationTables](compass.needle.v1.NeedleService.DelegationTables)
type DelegationTablesResponse struct {
	// Delegation tables
	DelegationTables []*DelegationTable `protobuf:"bytes,1,rep,name=delegation_tables,json=delegationTables" json:"delegation_tables,omitempty"`
}

func (m *DelegationTablesResponse) Reset()                    { *m = DelegationTablesResponse{} }
func (m *DelegationTablesResponse) String() string            { return proto.CompactTextString(m) }
func (*DelegationTablesResponse) ProtoMessage()               {}
func (*DelegationTablesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *DelegationTablesResponse) GetDelegationTables() []*DelegationTable {
	if m != nil {
		return m.DelegationTables
	}
	return nil
}

// Request for [Dentries](compass.needle.v1.NeedleService.Dentries)
type DentriesRequest struct {
	// Delegation Tables to get Dentries for
	Dtab string `protobuf:"bytes,1,opt,name=dtab" json:"dtab,omitempty"`
}

func (m *DentriesRequest) Reset()                    { *m = DentriesRequest{} }
func (m *DentriesRequest) String() string            { return proto.CompactTextString(m) }
func (*DentriesRequest) ProtoMessage()               {}
func (*DentriesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *DentriesRequest) GetDtab() string {
	if m != nil {
		return m.Dtab
	}
	return ""
}

// Response for [DelegationTables](compass.needle.v1.NeedleService.DelegationTables)
type DentriesResponse struct {
	// Dentries in the delegation table
	Dentries []*Dentry `protobuf:"bytes,1,rep,name=dentries" json:"dentries,omitempty"`
}

func (m *DentriesResponse) Reset()                    { *m = DentriesResponse{} }
func (m *DentriesResponse) String() string            { return proto.CompactTextString(m) }
func (*DentriesResponse) ProtoMessage()               {}
func (*DentriesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *DentriesResponse) GetDentries() []*Dentry {
	if m != nil {
		return m.Dentries
	}
	return nil
}

func init() {
	proto.RegisterType((*DataMigrationUpgradeRequest)(nil), "services.needle.DataMigrationUpgradeRequest")
	proto.RegisterType((*DataMigrationUpgradeResponse)(nil), "services.needle.DataMigrationUpgradeResponse")
	proto.RegisterType((*DataMigrationVersionRequest)(nil), "services.needle.DataMigrationVersionRequest")
	proto.RegisterType((*DataMigrationVersionResponse)(nil), "services.needle.DataMigrationVersionResponse")
	proto.RegisterType((*Service)(nil), "services.needle.Service")
	proto.RegisterType((*DelegationTable)(nil), "services.needle.DelegationTable")
	proto.RegisterType((*Dentry)(nil), "services.needle.Dentry")
	proto.RegisterType((*PutServiceRequest)(nil), "services.needle.PutServiceRequest")
	proto.RegisterType((*PutServiceResponse)(nil), "services.needle.PutServiceResponse")
	proto.RegisterType((*PutDentryRequest)(nil), "services.needle.PutDentryRequest")
	proto.RegisterType((*PutDentryResponse)(nil), "services.needle.PutDentryResponse")
	proto.RegisterType((*RouteToVersionRequest)(nil), "services.needle.RouteToVersionRequest")
	proto.RegisterType((*RouteToVersionResponse)(nil), "services.needle.RouteToVersionResponse")
	proto.RegisterType((*DeleteDentryByIdRequest)(nil), "services.needle.DeleteDentryByIdRequest")
	proto.RegisterType((*DeleteDentryByIdResponse)(nil), "services.needle.DeleteDentryByIdResponse")
	proto.RegisterType((*DeleteDentryByPrefixRequest)(nil), "services.needle.DeleteDentryByPrefixRequest")
	proto.RegisterType((*DeleteDentryByPrefixResponse)(nil), "services.needle.DeleteDentryByPrefixResponse")
	proto.RegisterType((*DelegationTablesRequest)(nil), "services.needle.DelegationTablesRequest")
	proto.RegisterType((*DelegationTablesResponse)(nil), "services.needle.DelegationTablesResponse")
	proto.RegisterType((*DentriesRequest)(nil), "services.needle.DentriesRequest")
	proto.RegisterType((*DentriesResponse)(nil), "services.needle.DentriesResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DataMigrationService service

type DataMigrationServiceClient interface {
	Upgrade(ctx context.Context, in *DataMigrationUpgradeRequest, opts ...grpc.CallOption) (*DataMigrationUpgradeResponse, error)
	Version(ctx context.Context, in *DataMigrationVersionRequest, opts ...grpc.CallOption) (*DataMigrationVersionResponse, error)
}

type dataMigrationServiceClient struct {
	cc *grpc.ClientConn
}

func NewDataMigrationServiceClient(cc *grpc.ClientConn) DataMigrationServiceClient {
	return &dataMigrationServiceClient{cc}
}

func (c *dataMigrationServiceClient) Upgrade(ctx context.Context, in *DataMigrationUpgradeRequest, opts ...grpc.CallOption) (*DataMigrationUpgradeResponse, error) {
	out := new(DataMigrationUpgradeResponse)
	err := grpc.Invoke(ctx, "/services.needle.DataMigrationService/Upgrade", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataMigrationServiceClient) Version(ctx context.Context, in *DataMigrationVersionRequest, opts ...grpc.CallOption) (*DataMigrationVersionResponse, error) {
	out := new(DataMigrationVersionResponse)
	err := grpc.Invoke(ctx, "/services.needle.DataMigrationService/Version", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DataMigrationService service

type DataMigrationServiceServer interface {
	Upgrade(context.Context, *DataMigrationUpgradeRequest) (*DataMigrationUpgradeResponse, error)
	Version(context.Context, *DataMigrationVersionRequest) (*DataMigrationVersionResponse, error)
}

func RegisterDataMigrationServiceServer(s *grpc.Server, srv DataMigrationServiceServer) {
	s.RegisterService(&_DataMigrationService_serviceDesc, srv)
}

func _DataMigrationService_Upgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataMigrationUpgradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataMigrationServiceServer).Upgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.needle.DataMigrationService/Upgrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataMigrationServiceServer).Upgrade(ctx, req.(*DataMigrationUpgradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataMigrationService_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataMigrationVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataMigrationServiceServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.needle.DataMigrationService/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataMigrationServiceServer).Version(ctx, req.(*DataMigrationVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataMigrationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "services.needle.DataMigrationService",
	HandlerType: (*DataMigrationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Upgrade",
			Handler:    _DataMigrationService_Upgrade_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _DataMigrationService_Version_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/needle.proto",
}

// Client API for DentryService service

type DentryServiceClient interface {
	// PutService upserts services to be managed
	PutService(ctx context.Context, in *PutServiceRequest, opts ...grpc.CallOption) (*PutServiceResponse, error)
	// DelegationTables returns a list of delegation tables we are managing
	DelegationTables(ctx context.Context, in *DelegationTablesRequest, opts ...grpc.CallOption) (*DelegationTablesResponse, error)
	// Dentries returns for a dtab
	Dentries(ctx context.Context, in *DentriesRequest, opts ...grpc.CallOption) (*DentriesResponse, error)
	// PutDentry upserts dentries to be managed
	PutDentry(ctx context.Context, in *PutDentryRequest, opts ...grpc.CallOption) (*PutDentryResponse, error)
	// DeleteDentryById deletes a dentry by it's UUID
	DeleteDentryById(ctx context.Context, in *DeleteDentryByIdRequest, opts ...grpc.CallOption) (*DeleteDentryByIdResponse, error)
	// DeleteDentryByPrefix deletes a dentry by prefix within a dtab
	DeleteDentryByPrefix(ctx context.Context, in *DeleteDentryByPrefixRequest, opts ...grpc.CallOption) (*DeleteDentryByPrefixResponse, error)
	// RouteToVersion routes a specific logical name to a specifc lubernetets services
	// based on a services logicalName and version labels
	RouteToVersion(ctx context.Context, in *RouteToVersionRequest, opts ...grpc.CallOption) (*RouteToVersionResponse, error)
}

type dentryServiceClient struct {
	cc *grpc.ClientConn
}

func NewDentryServiceClient(cc *grpc.ClientConn) DentryServiceClient {
	return &dentryServiceClient{cc}
}

func (c *dentryServiceClient) PutService(ctx context.Context, in *PutServiceRequest, opts ...grpc.CallOption) (*PutServiceResponse, error) {
	out := new(PutServiceResponse)
	err := grpc.Invoke(ctx, "/services.needle.DentryService/PutService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dentryServiceClient) DelegationTables(ctx context.Context, in *DelegationTablesRequest, opts ...grpc.CallOption) (*DelegationTablesResponse, error) {
	out := new(DelegationTablesResponse)
	err := grpc.Invoke(ctx, "/services.needle.DentryService/DelegationTables", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dentryServiceClient) Dentries(ctx context.Context, in *DentriesRequest, opts ...grpc.CallOption) (*DentriesResponse, error) {
	out := new(DentriesResponse)
	err := grpc.Invoke(ctx, "/services.needle.DentryService/Dentries", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dentryServiceClient) PutDentry(ctx context.Context, in *PutDentryRequest, opts ...grpc.CallOption) (*PutDentryResponse, error) {
	out := new(PutDentryResponse)
	err := grpc.Invoke(ctx, "/services.needle.DentryService/PutDentry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dentryServiceClient) DeleteDentryById(ctx context.Context, in *DeleteDentryByIdRequest, opts ...grpc.CallOption) (*DeleteDentryByIdResponse, error) {
	out := new(DeleteDentryByIdResponse)
	err := grpc.Invoke(ctx, "/services.needle.DentryService/DeleteDentryById", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dentryServiceClient) DeleteDentryByPrefix(ctx context.Context, in *DeleteDentryByPrefixRequest, opts ...grpc.CallOption) (*DeleteDentryByPrefixResponse, error) {
	out := new(DeleteDentryByPrefixResponse)
	err := grpc.Invoke(ctx, "/services.needle.DentryService/DeleteDentryByPrefix", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dentryServiceClient) RouteToVersion(ctx context.Context, in *RouteToVersionRequest, opts ...grpc.CallOption) (*RouteToVersionResponse, error) {
	out := new(RouteToVersionResponse)
	err := grpc.Invoke(ctx, "/services.needle.DentryService/RouteToVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DentryService service

type DentryServiceServer interface {
	// PutService upserts services to be managed
	PutService(context.Context, *PutServiceRequest) (*PutServiceResponse, error)
	// DelegationTables returns a list of delegation tables we are managing
	DelegationTables(context.Context, *DelegationTablesRequest) (*DelegationTablesResponse, error)
	// Dentries returns for a dtab
	Dentries(context.Context, *DentriesRequest) (*DentriesResponse, error)
	// PutDentry upserts dentries to be managed
	PutDentry(context.Context, *PutDentryRequest) (*PutDentryResponse, error)
	// DeleteDentryById deletes a dentry by it's UUID
	DeleteDentryById(context.Context, *DeleteDentryByIdRequest) (*DeleteDentryByIdResponse, error)
	// DeleteDentryByPrefix deletes a dentry by prefix within a dtab
	DeleteDentryByPrefix(context.Context, *DeleteDentryByPrefixRequest) (*DeleteDentryByPrefixResponse, error)
	// RouteToVersion routes a specific logical name to a specifc lubernetets services
	// based on a services logicalName and version labels
	RouteToVersion(context.Context, *RouteToVersionRequest) (*RouteToVersionResponse, error)
}

func RegisterDentryServiceServer(s *grpc.Server, srv DentryServiceServer) {
	s.RegisterService(&_DentryService_serviceDesc, srv)
}

func _DentryService_PutService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DentryServiceServer).PutService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.needle.DentryService/PutService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DentryServiceServer).PutService(ctx, req.(*PutServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DentryService_DelegationTables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelegationTablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DentryServiceServer).DelegationTables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.needle.DentryService/DelegationTables",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DentryServiceServer).DelegationTables(ctx, req.(*DelegationTablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DentryService_Dentries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DentriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DentryServiceServer).Dentries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.needle.DentryService/Dentries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DentryServiceServer).Dentries(ctx, req.(*DentriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DentryService_PutDentry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutDentryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DentryServiceServer).PutDentry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.needle.DentryService/PutDentry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DentryServiceServer).PutDentry(ctx, req.(*PutDentryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DentryService_DeleteDentryById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDentryByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DentryServiceServer).DeleteDentryById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.needle.DentryService/DeleteDentryById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DentryServiceServer).DeleteDentryById(ctx, req.(*DeleteDentryByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DentryService_DeleteDentryByPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDentryByPrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DentryServiceServer).DeleteDentryByPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.needle.DentryService/DeleteDentryByPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DentryServiceServer).DeleteDentryByPrefix(ctx, req.(*DeleteDentryByPrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DentryService_RouteToVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteToVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DentryServiceServer).RouteToVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.needle.DentryService/RouteToVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DentryServiceServer).RouteToVersion(ctx, req.(*RouteToVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DentryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "services.needle.DentryService",
	HandlerType: (*DentryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PutService",
			Handler:    _DentryService_PutService_Handler,
		},
		{
			MethodName: "DelegationTables",
			Handler:    _DentryService_DelegationTables_Handler,
		},
		{
			MethodName: "Dentries",
			Handler:    _DentryService_Dentries_Handler,
		},
		{
			MethodName: "PutDentry",
			Handler:    _DentryService_PutDentry_Handler,
		},
		{
			MethodName: "DeleteDentryById",
			Handler:    _DentryService_DeleteDentryById_Handler,
		},
		{
			MethodName: "DeleteDentryByPrefix",
			Handler:    _DentryService_DeleteDentryByPrefix_Handler,
		},
		{
			MethodName: "RouteToVersion",
			Handler:    _DentryService_RouteToVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/needle.proto",
}

func init() { proto.RegisterFile("services/needle.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 804 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xdb, 0x6e, 0xd3, 0x4a,
	0x14, 0x8d, 0x93, 0x36, 0x97, 0x9d, 0xd3, 0xdb, 0xa8, 0x17, 0x1f, 0xb7, 0x3d, 0x27, 0x35, 0x02,
	0x52, 0x09, 0x12, 0x29, 0xe5, 0x01, 0x89, 0xb7, 0x12, 0xa9, 0xf4, 0xa1, 0xa8, 0x98, 0x00, 0x12,
	0x2f, 0xd1, 0x24, 0x33, 0x0d, 0x23, 0x25, 0xb6, 0xb1, 0x27, 0x15, 0xfd, 0x16, 0x3e, 0x87, 0xbf,
	0xe1, 0x03, 0x78, 0x46, 0x9e, 0x8b, 0x13, 0x5f, 0x92, 0xb4, 0xf0, 0x16, 0xef, 0xbd, 0xf6, 0xde,
	0xb3, 0xd7, 0xac, 0x59, 0x81, 0xbd, 0x90, 0x06, 0xb7, 0x6c, 0x48, 0xc3, 0xb6, 0x4b, 0x29, 0x19,
	0xd3, 0x96, 0x1f, 0x78, 0xdc, 0x43, 0x5b, 0x3a, 0xdc, 0x92, 0x61, 0xeb, 0xff, 0x91, 0xe7, 0x8d,
	0xc6, 0xb4, 0x2d, 0xd2, 0x83, 0xe9, 0x4d, 0x9b, 0xb3, 0x09, 0x0d, 0x39, 0x9e, 0xf8, 0xb2, 0xc2,
	0x3e, 0x86, 0xc3, 0x2e, 0xe6, 0xf8, 0x8a, 0x8d, 0x02, 0xcc, 0x99, 0xe7, 0x7e, 0xf0, 0x47, 0x01,
	0x26, 0xd4, 0xa1, 0x5f, 0xa7, 0x34, 0xe4, 0xf6, 0x7f, 0x70, 0x94, 0x9f, 0x0e, 0x7d, 0xcf, 0x0d,
	0x69, 0xa6, 0xfc, 0x23, 0x0d, 0x42, 0xe6, 0xb9, 0xba, 0xfc, 0x65, 0xaa, 0x3c, 0x4e, 0xcb, 0x72,
	0x64, 0x42, 0xe5, 0x56, 0x86, 0x4c, 0xa3, 0x61, 0x34, 0x37, 0x1c, 0xfd, 0x69, 0xff, 0x32, 0xa0,
	0xf2, 0x5e, 0x2e, 0x83, 0x36, 0xa1, 0xc8, 0x88, 0x00, 0xd4, 0x9c, 0x22, 0x23, 0xe8, 0x15, 0xd4,
	0x87, 0x01, 0xc5, 0x9c, 0xf6, 0x09, 0xe6, 0xd4, 0x2c, 0x36, 0x8c, 0x66, 0xbd, 0x63, 0xb5, 0xe4,
	0xaa, 0x2d, 0xbd, 0x6a, 0xab, 0xa7, 0x57, 0x75, 0x40, 0xc2, 0xbb, 0x98, 0xd3, 0xa8, 0x78, 0xea,
	0x93, 0xb8, 0xb8, 0xb4, 0xba, 0x58, 0xc2, 0x45, 0xf1, 0x09, 0xfc, 0x33, 0xf6, 0x46, 0x6c, 0x88,
	0xc7, 0x7d, 0x17, 0x4f, 0xa8, 0xb9, 0x26, 0xce, 0x54, 0x57, 0xb1, 0xb7, 0x78, 0x42, 0xd1, 0x11,
	0xd4, 0xa2, 0x54, 0xe8, 0xe3, 0x21, 0x35, 0xd7, 0x45, 0x7e, 0x16, 0x40, 0x0d, 0xa8, 0x13, 0x1a,
	0x0e, 0x03, 0xe6, 0x47, 0x74, 0x98, 0x65, 0x59, 0x3f, 0x17, 0xb2, 0x1f, 0xc3, 0x56, 0x97, 0x8e,
	0xe9, 0x48, 0xf0, 0xd5, 0xc3, 0x83, 0x31, 0x45, 0x08, 0xd6, 0xc4, 0x34, 0xc9, 0x80, 0xf8, 0x6d,
	0x7f, 0x2f, 0x42, 0xb9, 0x4b, 0x5d, 0x1e, 0xdc, 0x65, 0xe8, 0x39, 0x06, 0x50, 0x32, 0xe8, 0x33,
	0x22, 0xd8, 0xa9, 0x39, 0x35, 0x15, 0xb9, 0xcc, 0xb0, 0x57, 0xfa, 0x1b, 0xf6, 0xd6, 0x1e, 0xc4,
	0xde, 0x3e, 0x94, 0xfd, 0x80, 0xde, 0xb0, 0x6f, 0x8a, 0x17, 0xf5, 0xa5, 0x48, 0xe1, 0xcc, 0xc5,
	0x29, 0x52, 0x74, 0x28, 0x62, 0x80, 0x70, 0x3c, 0x30, 0x2b, 0x92, 0x81, 0xe8, 0x37, 0xb2, 0xa0,
	0xea, 0x07, 0xcc, 0x0b, 0x18, 0xbf, 0x33, 0xab, 0x0d, 0xa3, 0xb9, 0xee, 0xc4, 0xdf, 0xf6, 0x05,
	0xec, 0x5c, 0x4f, 0xb9, 0xd2, 0x8f, 0x12, 0x23, 0xea, 0x40, 0x45, 0xb1, 0x20, 0xc8, 0xaa, 0x77,
	0xcc, 0x56, 0xea, 0xb9, 0xb4, 0x74, 0x85, 0x06, 0xda, 0x6f, 0x00, 0xcd, 0x37, 0x52, 0xb2, 0xfd,
	0x93, 0x4e, 0xaf, 0x61, 0xfb, 0x7a, 0xca, 0xe5, 0x95, 0xe9, 0x13, 0xb5, 0xa1, 0x4c, 0x44, 0x40,
	0xb5, 0x39, 0xc8, 0xb4, 0x51, 0x78, 0x05, 0xb3, 0xbb, 0x62, 0x2f, 0xdd, 0x44, 0x9d, 0xe6, 0xc1,
	0x5d, 0x7a, 0xb0, 0xe7, 0x78, 0x53, 0x4e, 0x7b, 0x5e, 0xf2, 0xb9, 0x66, 0xe4, 0x6d, 0x64, 0xe5,
	0x3d, 0xf7, 0x62, 0x4b, 0x22, 0x1b, 0xbf, 0x58, 0x13, 0xf6, 0xd3, 0x5d, 0x95, 0x49, 0x9c, 0xc2,
	0x41, 0x24, 0x69, 0x4e, 0xe5, 0x39, 0xce, 0xef, 0x2e, 0x89, 0x9e, 0x98, 0xd2, 0xae, 0xfd, 0x02,
	0xcc, 0x2c, 0x74, 0x66, 0x16, 0x44, 0xe4, 0x64, 0x41, 0xd5, 0xd1, 0x9f, 0xf6, 0x25, 0x1c, 0x26,
	0xab, 0xae, 0x85, 0xb0, 0xf4, 0x10, 0xad, 0x1e, 0x63, 0x4e, 0x3d, 0x33, 0x2d, 0x16, 0xe7, 0xb5,
	0x28, 0x1c, 0x2b, 0xb7, 0xd5, 0xca, 0x43, 0xfc, 0x2b, 0xb7, 0x9c, 0x7b, 0xb8, 0xa1, 0xb6, 0x41,
	0x26, 0xb7, 0x4a, 0xa6, 0x54, 0xc3, 0x2b, 0xd8, 0x21, 0x71, 0xae, 0xcf, 0x45, 0xd2, 0x34, 0x1a,
	0xa5, 0x66, 0xbd, 0xd3, 0xc8, 0xb9, 0xc8, 0x44, 0x17, 0x67, 0x9b, 0xa4, 0xda, 0x4a, 0xfb, 0x70,
	0x79, 0xc0, 0xe2, 0xe9, 0x79, 0xeb, 0xdb, 0x17, 0xb0, 0x3d, 0x83, 0xa9, 0x93, 0x9c, 0x41, 0x95,
	0xa8, 0x98, 0x3a, 0xc0, 0x42, 0x25, 0xc5, 0xc0, 0xce, 0x4f, 0x03, 0x76, 0x13, 0x16, 0xaf, 0x4d,
	0xfb, 0x0b, 0x54, 0xd4, 0x9f, 0x05, 0x7a, 0x96, 0x6d, 0xb3, 0xf8, 0x2f, 0xc7, 0x7a, 0x7e, 0x4f,
	0xb4, 0x12, 0x57, 0x21, 0x9a, 0xa4, 0x14, 0xb7, 0x6a, 0x52, 0x52, 0xee, 0xab, 0x26, 0xa5, 0x65,
	0x5c, 0xe8, 0xfc, 0x58, 0x87, 0x0d, 0xc9, 0x80, 0xde, 0xf2, 0x13, 0xc0, 0xcc, 0x1f, 0x90, 0x9d,
	0x69, 0x98, 0x71, 0x21, 0xeb, 0xd1, 0x52, 0x4c, 0xbc, 0x14, 0x8b, 0x2e, 0x28, 0x79, 0xb7, 0xa8,
	0xb9, 0x4a, 0x0f, 0xfa, 0xca, 0xad, 0xd3, 0x7b, 0x20, 0xe3, 0x51, 0xef, 0xa0, 0xaa, 0xb5, 0x80,
	0x1a, 0xf9, 0x37, 0x3e, 0x53, 0x93, 0x75, 0xb2, 0x04, 0x11, 0xb7, 0xec, 0x41, 0x2d, 0xf6, 0x29,
	0x74, 0x92, 0xb7, 0x71, 0xc2, 0x08, 0x2d, 0x7b, 0x19, 0x24, 0xcd, 0xc9, 0xbc, 0x39, 0x2c, 0xe0,
	0x24, 0xc7, 0x6a, 0x16, 0x70, 0x92, 0xe7, 0x34, 0x76, 0x01, 0x4d, 0x61, 0x37, 0xcf, 0x06, 0xf2,
	0x04, 0xb6, 0xd8, 0x78, 0xf2, 0x04, 0xb6, 0xc4, 0x5b, 0xec, 0x02, 0x1a, 0xc2, 0x66, 0xd2, 0x43,
	0xd1, 0x93, 0x4c, 0x8b, 0x5c, 0xeb, 0xb6, 0x9e, 0xae, 0xc4, 0xe9, 0x21, 0xe7, 0xf0, 0xb9, 0xaa,
	0xb1, 0x83, 0xb2, 0xf8, 0xcb, 0x3e, 0xfb, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x2c, 0xe3, 0x1e, 0x08,
	0x50, 0x0a, 0x00, 0x00,
}
